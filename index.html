<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Merkf√§higkeitstrainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.fonts.inter.org/inter.css');

        /* --- Grundlayout --- */
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100dvh;
            transition: background-color 0.3s, color 0.3s;
            padding: 1rem;
        }

        .main-card {
            background-color: #1e293b;
            border-color: #334155;
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.7);
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            width: 100%;
            max-width: 480px;
            box-sizing: border-box;
            margin: auto;
        }

        /* Info- und Textfarben */
        .info-panel {
            background-color: #334155;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .text-title {
            color: #f1f5f9;
        }

        .text-subtitle {
            color: #94a3b8;
        }

        /* Grid Setup */
        .game-grid {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            border-radius: 12px;
            position: relative;
            aspect-ratio: 1 / 1;
            width: 90vw;
            max-width: 400px;
            max-height: 90vw;
            margin: 0 auto;
        }

        .grid-container-inner {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 12px;
            width: 100%;
            height: 100%;
        }

        .grid-cell {
            background-color: #475569;
            transition: background-color 0.1s ease-in-out, transform 0.1s;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            user-select: none;
        }

        /* --- Farben & Effekte --- */
        .flash-active {
            background-color: #1bc9b7 !important;
            box-shadow: 0 0 15px #1bc9b7, 0 0 5px #3bffeb;
        }

        .correct-click {
            background-color: #4ade80 !important;
            box-shadow: 0 0 25px #4ade80;
        }

        .wrong-click {
            background-color: #ef4444 !important;
            box-shadow: 0 0 15px #ef4444, 0 0 5px #fca5a5;
        }

        .should-have-been-clicked {
            background-color: #fbbf24 !important;
            box-shadow: 0 0 15px #fbbf24, 0 0 5px #fcd34d;
        }

        .phase-complete {
            background-color: #36cda0 !important;
            box-shadow: 0 0 20px #10b981;
        }

        .correct-before-failure {
            background-color: #189a77 !important;
            box-shadow: 0 0 8px #4fecc2;
        }

        /* Idle-Animation Klassen */
        @keyframes idle-soft-turquoise {

            0%,
            100% {
                background-color: #475569;
                box-shadow: 0 0 5px rgba(34, 211, 238, 0.2);
            }

            50% {
                background-color: #22d3ee;
                box-shadow: 0 0 12px rgba(34, 211, 238, 0.4);
            }
        }

        @keyframes idle-soft-red {

            0%,
            100% {
                background-color: #475569;
                box-shadow: 0 0 5px rgba(239, 68, 68, 0.2);
            }

            50% {
                background-color: #ef4444;
                box-shadow: 0 0 12px rgba(239, 68, 68, 0.5);
            }
        }

        @keyframes idle-soft-gold {

            0%,
            100% {
                background-color: #475569;
                box-shadow: 0 0 5px rgba(251, 191, 36, 0.2);
            }

            50% {
                background-color: #fbbf24;
                box-shadow: 0 0 12px rgba(251, 191, 36, 0.5);
            }
        }

        .idle-soft-turquoise {
            animation: idle-soft-turquoise 4s ease-in-out infinite;
        }

        .idle-soft-red {
            animation: idle-soft-red 4s ease-in-out infinite;
        }

        .idle-soft-gold {
            animation: idle-soft-gold 4s ease-in-out infinite;
        }

        .idle-fadeout {
            animation: none !important;
            transition: background-color 0.2s linear, box-shadow 0.2s linear;
            background-color: #475569 !important;
            box-shadow: none !important;
        }

        /* Timer */
        #time-bar-container {
            height: 10px;
            background-color: #475569;
            border-radius: 9999px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        #time-bar {
            height: 100%;
            width: 100%;
            transition: width 0s linear;
        }

        /* Overlay */
        #start-button-overlay {
            z-index: 10;
            opacity: 1;
            pointer-events: auto;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(30, 41, 59, 0.9);
            border-radius: 12px;
        }

        #start-button {
            box-shadow: 0 0 20px #0b7068, 0 0 10px #119b90;
            border: none;
        }

        #start-button:hover {
            transform: scale(1.05);
        }

        /* Light Mode */
        body.light-mode {
            background-color: #f0f4f8;
            color: #1e293b;
        }

        .light-mode .main-card {
            background-color: #ffffff;
            border-color: #e2e8f0;
        }

        .light-mode .info-panel {
            background-color: #f7f9fc;
        }

        .light-mode .grid-cell {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
        }

        .light-mode #start-button-overlay {
            background-color: rgba(255, 255, 255, 0.9);
        }

        /* --- Mobile Fixes --- */
        @media (max-width: 640px) {
            body {
                align-items: flex-start;
                justify-content: center;
                min-height: 100dvh;
                padding: 0.5rem;
            }

            .main-card {
                width: 100%;
                max-width: 95vw;
                margin: auto;
            }

            .game-grid {
                width: 100%;
                max-width: 90vw;
                max-height: 90vw;
                margin: 0 auto;
            }

            #start-button {
                font-size: 1rem;
                padding: 0.75rem 1.5rem;
            }

            #game-message {
                font-size: 0.95rem;
            }
        }
    </style>

    <!-- FIREBASE import -->
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js"></script>

</head>

<body class="dark-mode">

    <!-- Theme Switch -->
    <div class="absolute top-4 left-4 z-20">
        <label for="theme-switch" class="flex items-center cursor-pointer theme-switch-label">
            <input id="theme-switch" type="checkbox" class="sr-only">
            <div class="relative">
                <div class="w-10 h-4 rounded-full shadow-inner"></div>
                <div class="dot absolute w-6 h-6 rounded-full shadow -left-1 -top-1"></div>
            </div>
            <span id="theme-label" class="ml-3 text-sm font-medium">Dark Mode</span>
        </label>
    </div>
    
    <!-- Hauptcontainer -->
    <div class="w-full main-card p-6 rounded-xl border">
        <h1 class="text-3xl font-extrabold text-center mb-4 text-title">Ged√§chtnis-Sequenz-Trainer</h1>
        <p class="text-center text-sm mb-6 font-semibold text-subtitle">
            Merken Sie sich die <b>gesamte Musterabfolge</b> Phase f√ºr Phase. Das <b>Zeitlimit</b> gilt f√ºr die gesamte
            Runde.
        </p>

        <!-- Status und Timer -->
        <div class="flex justify-between items-center mb-6 p-3 info-panel rounded-lg shadow-inner">
            <div class="text-center">
                <p class="text-xs font-semibold uppercase text-gray-400">Aktuelle Runde</p>
                <p id="current-round" class="text-2xl font-bold text-title">1</p>
            </div>
            <div class="text-center">
                <p class="text-xs font-semibold uppercase text-gray-400">H√∂chste Runde</p>
                <p id="high-score" class="text-2xl font-bold text-red-400">Laden...</p>
            </div>
        </div>

        <div id="time-bar-container" class="hidden">
            <div id="time-bar"></div>
        </div>

        <!-- Spielgitter -->
        <div id="game-grid" class="game-grid mx-auto grid-bg">
            <div id="grid-container-inner" class="grid-container-inner"></div>

            <div id="start-button-overlay">
                <button id="start-button"
                    class="py-4 px-8 bg-teal-700 text-white font-bold text-xl rounded-full hover:bg-teal-600 transition duration-150 ease-in-out">
                    START
                </button>
            </div>
        </div>

        <!-- Nachrichten -->
        <div class="mt-6 text-center">
            <p id="game-message" class="text-lg font-semibold h-6 mb-4 text-title">Dr√ºcken Sie START, um zu beginnen.
            </p>

            <button id="strategy-button"
                class="w-full py-2 px-4 mt-3 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-800 transition duration-150 ease-in-out hidden">
                ‚ú® Ged√§chtnistipps anfordern
            </button>

            <div id="strategy-output" class="mt-4 p-4 rounded-lg text-sm text-left border strategy-output hidden">
                <p class="font-bold mb-2 strategy-header">Ged√§chtnistipps:</p>
                <div id="strategy-content" class="text-subtitle"></div>
                <div id="loading-spinner" class="text-center hidden">
                    <div class="inline-block h-4 w-4 animate-spin rounded-full border-2 border-solid border-current border-r-transparent align-[-0.125em]"
                        role="status"></div>
                    <span class="ml-2 text-gray-400">Lade Tipps...</span>
                </div>
            </div>
        </div>

        <p id="user-info" class="text-xs text-gray-500 mt-4 text-center"></p>
    </div>

    <!-- Kompletter JavaScript-Block (bereinigt & lauff√§hig) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

  // ----------------------------
  // üîß Firebase Setup
  // ----------------------------
  const firebaseConfig = {
    apiKey: "AIzaSyDdZqXYU6oR6yahRt4R5uyObashSScCyf0",
    authDomain: "merkdings.firebaseapp.com",
    projectId: "merkdings",
    storageBucket: "merkdings.firebasestorage.app",
    messagingSenderId: "50434008709",
    appId: "1:50434008709:web:0f1583b896ec853f8b6bec",
    measurementId: "G-ZXRVNCPQ4Y"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  let userId = null;
  let personalHighscore = 0;
  let globalHighscore = 0;

  // ----------------------------
  // üî• Initialisierung
  // ----------------------------
  document.addEventListener("DOMContentLoaded", async () => {
    await initializeFirebase();
  });

  async function initializeFirebase() {
    try {
      console.log("üîå Firebase wird initialisiert...");

      const savedUid = localStorage.getItem("firebaseAnonUid");
      if (savedUid) {
        userId = savedUid;
      } else {
        const result = await signInAnonymously(auth);
        userId = result.user?.uid;
        localStorage.setItem("firebaseAnonUid", userId);
      }

      console.log("‚úÖ Angemeldet als:", userId);

      // Highscores abrufen
      await loadHighscores();

      // Realtime Listener f√ºr eigenen Score
      const userRef = doc(db, "artifacts", "memory-app", "users", userId, "memory_game_scores", "high_score");
      onSnapshot(userRef, (docSnap) => {
        if (docSnap.exists()) {
          personalHighscore = docSnap.data().maxRound || 0;
          updateScoreDisplay();
        }
      });

    } catch (err) {
      console.error("‚ùå Fehler bei Firebase:", err);
      setupLocalHighscore();
    }
  }

  // ----------------------------
  // üß† Highscores laden
  // ----------------------------
  async function loadHighscores() {
    const highScoreEl = document.getElementById("high-score");
    if (highScoreEl) highScoreEl.textContent = "0";

    try {
      // Eigener Score
      const userRef = doc(db, "artifacts", "memory-app", "users", userId, "memory_game_scores", "high_score");
      const userSnap = await getDoc(userRef);
      personalHighscore = userSnap.exists() ? userSnap.data().maxRound || 0 : 0;

      // Globaler Score (bester aller Nutzer)
      const globalQuery = query(
        collection(db, "artifacts", "memory-app", "users"),
        orderBy("maxRound", "desc"),
        limit(1)
      );

      const querySnap = await getDocs(globalQuery);
      if (!querySnap.empty) {
        const bestUser = querySnap.docs[0].data();
        globalHighscore = bestUser.maxRound || 0;
      }

      updateScoreDisplay();
      console.log("üèÜ Pers√∂nlicher Highscore:", personalHighscore);
      console.log("üåç Globaler Highscore:", globalHighscore);

    } catch (error) {
      console.error("Fehler beim Laden der Highscores:", error);
      setupLocalHighscore();
    }
  }

  // ----------------------------
  // üîÑ Score-Anzeige aktualisieren
  // ----------------------------
  function updateScoreDisplay() {
    const personalEl = document.getElementById("high-score");
    const globalEl = document.getElementById("global-score");

    if (personalEl) personalEl.textContent = personalHighscore;
    if (globalEl) globalEl.textContent = globalHighscore;
  }

  // ----------------------------
  // üíæ Highscore speichern
  // ----------------------------
  window.updateHighScore = async (newRound) => {
    if (newRound <= personalHighscore) return;

    personalHighscore = newRound;
    updateScoreDisplay();

    try {
      const userRef = doc(db, "artifacts", "memory-app", "users", userId, "memory_game_scores", "high_score");
      await setDoc(userRef, { maxRound: newRound, updatedAt: new Date().toISOString() }, { merge: true });
      console.log("‚úÖ Highscore aktualisiert:", newRound);
    } catch (e) {
      console.error("Fehler beim Speichern:", e);
      setupLocalHighscore();
    }
  };

  // ----------------------------
  // üíæ Lokaler Fallback
  // ----------------------------
  function setupLocalHighscore() {
    const saved = parseInt(localStorage.getItem("localHighScore")) || 0;
    personalHighscore = saved;
    document.getElementById("high-score").textContent = saved;
    console.log("üì¶ Lokaler Highscore aktiv:", saved);
  }

        // --- Spiel-Logik ---
        const GRID_SIZE = 9;
        const GRID_CONTAINER = document.getElementById('grid-container-inner');
        const MESSAGE_ELEMENT = document.getElementById('game-message');
        const ROUND_ELEMENT = document.getElementById('current-round');
        const START_BUTTON_OVERLAY = document.getElementById('start-button-overlay');
        const START_BUTTON = document.getElementById('start-button');
        const TIME_BAR = document.getElementById('time-bar');
        const TIME_BAR_CONTAINER = document.getElementById('time-bar-container');

        let idleInterval = null; // Idle-Interval hier global

        let gameState = {
            round: 1,
            numPhases: 2,
            patternSize: 3,
            sequence: [],
            isFlashing: false,
            isPlayerTurn: false,
            currentPhaseIndex: 0,
            phaseClicks: new Set(),
            flashDuration: 1000,
            waitDuration: 500,
            playerClickTimeLimit: 0,
            flashPhaseDuration: 0,
            timeoutId: null,
        };

        const API_KEY = "";
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Strategie-Anfrage (externes API - optional)
        const requestStrategyTips = async () => {
            const STRATEGY_BUTTON = document.getElementById('strategy-button');
            const STRATEGY_OUTPUT = document.getElementById('strategy-output');
            const STRATEGY_CONTENT = document.getElementById('strategy-content');
            const LOADING_SPINNER = document.getElementById('loading-spinner');

            STRATEGY_BUTTON.disabled = true;
            STRATEGY_OUTPUT.classList.remove('hidden');
            STRATEGY_CONTENT.innerHTML = '';
            LOADING_SPINNER.classList.remove('hidden');

            const systemPrompt = "Sie sind ein freundlicher und motivierender Ged√§chtnistrainer. Geben Sie klare, umsetzbare Ratschl√§ge, um das Arbeitsged√§chtnis und die Sequenzierungsf√§higkeit zu verbessern. Antworten Sie in pr√§gnanten Abs√§tzen auf Deutsch. Verwenden Sie Markdown f√ºr Formatierungen.";
            const userQuery = "Welche Strategien gibt es, um sich eine Abfolge von 3x3-Quadratmustern in Phasen zu merken, bei denen die Reihenfolge der Klicks innerhalb der Phase nicht wichtig ist? Ich muss 3 Felder in der vorgegebenen Zeit anklicken, bevor ich zur n√§chsten Phase √ºbergehe.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;

            try {
                const maxRetries = 3;
                let attempt = 0;
                let response;

                while (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000;
                    if (attempt > 0) await sleep(delay);

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) break;
                    attempt++;

                    if (attempt === maxRetries) throw new Error(`API-Fehler nach ${maxRetries} Versuchen: ${response.status}`);
                }

                const result = await response.json();
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Konnte keine Tipps generieren.";

                const formattedText = text
                    .replace(/\*\s/g, '‚Ä¢ ')
                    .replace(/\n\n/g, '<br><br>')
                    .replace(/\n/g, '<br>');

                STRATEGY_CONTENT.innerHTML = formattedText;

            } catch (error) {
                console.error("Fehler bei der Strategie-Anforderung:", error);
                STRATEGY_CONTENT.innerHTML = "Es ist ein Fehler aufgetreten. Bitte versuchen Sie es sp√§ter erneut.";
            } finally {
                LOADING_SPINNER.classList.add('hidden');
                STRATEGY_BUTTON.disabled = false;
            }
        };

        // Gitterzellen erstellen
        const createGrid = () => {
            GRID_CONTAINER.innerHTML = '';

            for (let i = 0; i < GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-xl', 'font-bold');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                GRID_CONTAINER.appendChild(cell);
            }
        };

        const calculateClickTimeLimit = () => {
            const baseTimePerPhase = 2500;
            const reductionPerComplexityLevel = 500;
            const minTimePerPhase = 1000;
            const complexityLevel = gameState.numPhases - 2;

            const timePerPhaseAfterReduction = Math.max(
                minTimePerPhase,
                baseTimePerPhase - complexityLevel * reductionPerComplexityLevel
            );

            return timePerPhaseAfterReduction * gameState.numPhases;
        }

        const startGame = async () => {
            stopIdleAnimation();

            const cells = Array.from(GRID_CONTAINER.children);
            cells.forEach(c => {
                c.classList.remove('idle-soft-turquoise', 'idle-soft-red', 'idle-soft-gold');
                c.classList.add('idle-fadeout');
                setTimeout(() => {
                    c.classList.remove('idle-fadeout');
                }, 250);
                c.style.animation = 'none';
                void c.offsetWidth;
                c.style.animation = '';
            });

            if (gameState.isFlashing || gameState.isPlayerTurn) return;

            START_BUTTON_OVERLAY.style.pointerEvents = 'none';
            START_BUTTON_OVERLAY.style.opacity = '0';
            START_BUTTON_OVERLAY.style.transform = 'scale(0.9)';

            await sleep(100);
            START_BUTTON_OVERLAY.classList.add('hidden');

            if (gameState.round === 1) {
                gameState.numPhases = 2;
                clearGridClasses();
            }

            stopCurrentTimer();
            gameState.isFlashing = true;
            gameState.isPlayerTurn = false;
            gameState.currentPhaseIndex = 0;
            gameState.phaseClicks.clear();

            MESSAGE_ELEMENT.textContent = 'Merken Sie sich die Sequenz (Phase 1)...';
            TIME_BAR_CONTAINER.classList.remove('hidden');

            document.getElementById('strategy-button').classList.add('hidden');
            document.getElementById('strategy-output').classList.add('hidden');

            gameState.sequence = generateSequence(gameState.numPhases, gameState.patternSize);

            gameState.flashPhaseDuration = gameState.numPhases * gameState.flashDuration + (gameState.numPhases - 1) * gameState.waitDuration;
            gameState.playerClickTimeLimit = calculateClickTimeLimit();

            startPhaseTimer(gameState.flashPhaseDuration, 'flash');

            await flashSequence();
            stopIdleAnimation();
        };

        const generateSequence = (numPhases, patternSize) => {
            const seq = [];
            const allIndices = Array.from({ length: GRID_SIZE }, (_, i) => i);

            for (let i = 0; i < numPhases; i++) {
                const pattern = [];
                let availableIndices = [...allIndices];

                for (let k = 0; k < Math.min(patternSize, GRID_SIZE); k++) {
                    const randomIndex = Math.floor(Math.random() * availableIndices.length);
                    const selectedIndex = availableIndices[randomIndex];

                    pattern.push(selectedIndex);
                    availableIndices.splice(randomIndex, 1);
                }
                seq.push(pattern);
            }
            return seq;
        };

        const flashSequence = async () => {
            const cells = Array.from(GRID_CONTAINER.children);

            for (let i = 0; i < gameState.sequence.length; i++) {
                if (!gameState.isFlashing) return;

                const pattern = gameState.sequence[i];

                MESSAGE_ELEMENT.textContent = `Merken Sie sich die Sequenz (Phase ${i + 1})...`;

                const activeCells = pattern.map(index => cells[index]);

                activeCells.forEach(cell => cell.classList.add('flash-active'));
                await sleep(gameState.flashDuration);

                activeCells.forEach(cell => cell.classList.remove('flash-active'));

                if (i < gameState.sequence.length - 1) {
                    await sleep(gameState.waitDuration);
                }
            }

            if (gameState.isFlashing) {
                stopCurrentTimer();
                startClickPhase();
            }
        };

        const startPhaseTimer = (duration, phaseType) => {
            stopCurrentTimer();

            let barColor;

            if (phaseType === 'flash') {
                barColor = '#fde047';
            } else if (phaseType === 'click') {
                barColor = '#f87171';
            }

            TIME_BAR.style.backgroundColor = barColor;
            TIME_BAR.style.transition = 'none';
            TIME_BAR.style.width = '100%';
            void TIME_BAR.offsetWidth;
            TIME_BAR.style.transition = `width ${duration}ms linear`;
            TIME_BAR.style.width = '0%';

            gameState.timeoutId = setTimeout(() => {
                handlePhaseTimeout(phaseType);
            }, duration);
        };

        const stopCurrentTimer = () => {
            if (gameState.timeoutId) {
                clearTimeout(gameState.timeoutId);
                gameState.timeoutId = null;
            }
            TIME_BAR.style.transition = 'none';
            TIME_BAR.style.width = '100%';
        };

        const startClickPhase = () => {
            gameState.isFlashing = false;
            gameState.isPlayerTurn = true;
            MESSAGE_ELEMENT.textContent = `Klicken Sie die Felder der Phase ${gameState.currentPhaseIndex + 1}! (Zeit l√§uft)`;

            startPhaseTimer(gameState.playerClickTimeLimit, 'click');
        };

        const handlePhaseTimeout = (phaseType) => {
            if (phaseType === 'flash') {
                if (gameState.isFlashing) {
                    console.log("Merkphase Timeout, aber Flashing l√§uft noch. Erzwinge Klickphase.");
                    gameState.isFlashing = false;
                    startClickPhase();
                }

            } else if (phaseType === 'click') {
                if (!gameState.isPlayerTurn) return;

                stopCurrentTimer();
                MESSAGE_ELEMENT.textContent = `ZEIT ABGELAUFEN! Game Over. Ihre erreichte Runde: ${gameState.round}.`;
                handleFailure(true);
            }
        };

        async function handleCellClick(event) {
            if (!gameState.isPlayerTurn) {
                console.log("Klick ignoriert: Nicht die Spielerrunde.");
                return;
            }

            const clickedCell = event.currentTarget;
            const clickedIndex = parseInt(clickedCell.dataset.index);

            const expectedPattern = gameState.sequence[gameState.currentPhaseIndex];

            if (expectedPattern.includes(clickedIndex)) {
                if (gameState.phaseClicks.has(clickedIndex)) {
                    return;
                }

                gameState.phaseClicks.add(clickedIndex);
                clickedCell.classList.add('phase-complete');

                clickedCell.classList.add('correct-click');
                setTimeout(() => clickedCell.classList.remove('correct-click'), 150);

                if (gameState.phaseClicks.size === gameState.patternSize) {
                    gameState.isPlayerTurn = false;

                    const cells = Array.from(GRID_CONTAINER.children);
                    const completedPattern = gameState.sequence[gameState.currentPhaseIndex];

                    completedPattern.forEach(index => {
                        cells[index].classList.remove('phase-complete');
                        cells[index].classList.add('correct-click');
                        setTimeout(() => cells[index].classList.remove('correct-click'), 300);
                    });

                    gameState.currentPhaseIndex++;

                    if (gameState.currentPhaseIndex === gameState.sequence.length) {
                        handleSuccess();
                    } else {
                        MESSAGE_ELEMENT.textContent = `Phase ${gameState.currentPhaseIndex} abgeschlossen! Klicken Sie die Felder der Phase ${gameState.currentPhaseIndex + 1}! (Zeit l√§uft)`;

                        gameState.phaseClicks.clear();
                        gameState.isPlayerTurn = true;
                    }
                }

            } else {
                stopCurrentTimer();
                clickedCell.classList.add('wrong-click');
                handleFailure(false);
            }
        }

        const handleSuccess = async () => {
            gameState.isPlayerTurn = false;
            stopCurrentTimer();

            MESSAGE_ELEMENT.textContent = 'Runde bestanden! N√§chste Runde wird vorbereitet...';

            await sleep(1500);

            const completedRound = gameState.round;
            window.updateHighScore(completedRound);

            gameState.round++;

            if ((gameState.round - 1) % 3 === 0) {
                gameState.numPhases++;
            }

            ROUND_ELEMENT.textContent = gameState.round;

            clearGridClasses();
            await sleep(500);

            startGame();
        };

        const handleFailure = async (isTimeout) => {
            gameState.isPlayerTurn = false;
            stopCurrentTimer();

            const cells = Array.from(GRID_CONTAINER.children);
            const expectedPattern = gameState.sequence[gameState.currentPhaseIndex] || [];
            const allMissingIndices = expectedPattern.filter(index => !gameState.phaseClicks.has(index));

            if (allMissingIndices.length > 0) {
                MESSAGE_ELEMENT.textContent = isTimeout
                    ? `ZEIT ABGELAUFEN! Game Over.`
                    : `FALSCH! Game Over.`;
            } else {
                MESSAGE_ELEMENT.textContent = `Game Over. Ihre erreichte Runde: ${gameState.round}.`;
            }

            cells.forEach(cell => cell.classList.add('wrong-click'));

            gameState.phaseClicks.forEach(index => {
                const correctCell = cells[index];
                if (correctCell) {
                    correctCell.classList.remove('wrong-click');
                    correctCell.classList.add('correct-before-failure');
                }
            });

            allMissingIndices.forEach(missingIndex => {
                const missedCell = cells[missingIndex];
                if (missedCell) {
                    missedCell.classList.remove('wrong-click');
                    missedCell.classList.add('should-have-been-clicked');
                }
            });

            await sleep(3000);

            //gameState.round = 1;
            //ROUND_ELEMENT.textContent = gameState.round;

            

            START_BUTTON.textContent = 'NEU STARTEN';
            START_BUTTON_OVERLAY.classList.remove('hidden');
            START_BUTTON_OVERLAY.style.opacity = '1';
            START_BUTTON_OVERLAY.style.transform = 'scale(1)';
            START_BUTTON_OVERLAY.style.pointerEvents = 'auto';

            document.getElementById('strategy-button').classList.remove('hidden');

            if (isTimeout) {
                startIdleAnimation('idle-soft-gold');
            } else {
                startIdleAnimation('idle-soft-red');
            }
        };

        const clearGridClasses = () => {
            const cells = Array.from(GRID_CONTAINER.children);
            cells.forEach(cell => {
                cell.classList.remove(
                    'flash-active',
                    'correct-click',
                    'wrong-click',
                    'phase-complete',
                    'should-have-been-clicked',
                    'correct-before-failure'
                );
            });
        }

        // Theme-Switch
        const setupThemeSwitch = () => {
            const body = document.body;
            const switchInput = document.getElementById('theme-switch');
            const switchLabel = document.getElementById('theme-label');

            const setDarkMode = (isDark) => {
                if (isDark) {
                    body.classList.remove('light-mode');
                    body.classList.add('dark-mode');
                    switchInput.checked = false;
                    //switchLabel.textContent = 'Dark Mode';
                } else {
                    body.classList.add('light-mode');
                    body.classList.remove('dark-mode');
                    switchInput.checked = true;
                    switchLabel.textContent = 'Light Mode';
                }
            };

            setDarkMode(true);

            switchInput.addEventListener('change', () => {
                setDarkMode(!switchInput.checked);
            });

        };

        // Idle Animation
        function startIdleAnimation(colorClass = 'idle-soft-turquoise') {
            stopIdleAnimation();

            idleInterval = setInterval(() => {
                const cells = Array.from(GRID_CONTAINER.children);
                if (cells.length === 0) return;
                const randomCell = cells[Math.floor(Math.random() * cells.length)];

                randomCell.classList.add(colorClass);

                setTimeout(() => {
                    randomCell.classList.remove(colorClass);
                }, 4000);
            }, 1500);
        }

        function stopIdleAnimation() {
            if (idleInterval) {
                clearInterval(idleInterval);
                idleInterval = null;
            }
            const cells = Array.from(GRID_CONTAINER.children);
            cells.forEach(c => {
                c.classList.remove('idle-soft-turquoise', 'idle-soft-red', 'idle-soft-gold', 'idle-fadeout');
            });
        }

        function showRestartOverlay() {
            START_BUTTON.textContent = 'NEU STARTEN';
            START_BUTTON_OVERLAY.classList.remove('hidden');
            START_BUTTON_OVERLAY.style.opacity = '1';
            START_BUTTON_OVERLAY.style.transform = 'scale(1)';
            START_BUTTON_OVERLAY.style.pointerEvents = 'auto';
            startIdleAnimation();
        }

        // Initialisierung auf load (einmalig, sauber)
        window.addEventListener('load', () => {
            createGrid();
            initializeFirebase();
            setupThemeSwitch();

            // Start: stoppe Idle und starte Spiel
            START_BUTTON.addEventListener('click', () => {
                stopIdleAnimation();
            
                if (START_BUTTON.textContent === 'NEU STARTEN') {
                    // Nur bei echtem Neustart alles zur√ºcksetzen
                    isRestart = true;
                    gameState.round = 1;
                    ROUND_ELEMENT.textContent = gameState.round;
                } else {
                    isRestart = false;
                }
            
                // Felder s√§ubern und verstecken
                clearGridClasses();
                START_BUTTON_OVERLAY.classList.add('hidden');
            
                startGame();
            });

            document.getElementById('strategy-button').addEventListener('click', requestStrategyTips);

            // Idle gleich beim Laden starten
            startIdleAnimation();
        });

    </script>

</body>


</html>






























