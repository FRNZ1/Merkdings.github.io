<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Merkfähigkeitstrainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.fonts.inter.org/inter.css');

        /* --- Grundlayout --- */
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100dvh;
            transition: background-color 0.3s, color 0.3s;
            padding: 1rem;
        }

        .main-card {
            background-color: #1e293b;
            border-color: #334155;
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.7);
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            width: 100%;
            max-width: 480px;
            box-sizing: border-box;
            margin: auto;
        }

        /* Info- und Textfarben */
        .info-panel {
            background-color: #334155;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .text-title {
            color: #f1f5f9;
        }

        .text-subtitle {
            color: #94a3b8;
        }

        /* Grid Setup */
        .game-grid {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            border-radius: 12px;
            position: relative;
            aspect-ratio: 1 / 1;
            width: 90vw;
            max-width: 400px;
            max-height: 90vw;
            margin: 0 auto;
        }

        .grid-container-inner {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 12px;
            width: 100%;
            height: 100%;
        }

        .grid-cell {
            background-color: #475569;
            transition: background-color 0.1s ease-in-out, transform 0.1s;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            user-select: none;
        }

        /* --- Farben & Effekte --- */
        .flash-active {
            background-color: #1bc9b7 !important;
            box-shadow: 0 0 15px #1bc9b7, 0 0 5px #3bffeb;
        }

        .correct-click {
            background-color: #4ade80 !important;
            box-shadow: 0 0 25px #4ade80;
        }

        .wrong-click {
            background-color: #ef4444 !important;
            box-shadow: 0 0 15px #ef4444, 0 0 5px #fca5a5;
        }

        .should-have-been-clicked {
            background-color: #fbbf24 !important;
            box-shadow: 0 0 15px #fbbf24, 0 0 5px #fcd34d;
        }

        .phase-complete {
            background-color: #36cda0 !important;
            box-shadow: 0 0 20px #10b981;
        }

        .correct-before-failure {
            background-color: #189a77 !important;
            box-shadow: 0 0 8px #4fecc2;
        }

        /* Idle-Animation Klassen */
        @keyframes idle-soft-turquoise {

            0%,
            100% {
                background-color: #475569;
                box-shadow: 0 0 5px rgba(34, 211, 238, 0.2);
            }

            50% {
                background-color: #22d3ee;
                box-shadow: 0 0 12px rgba(34, 211, 238, 0.4);
            }
        }

        @keyframes idle-soft-red {

            0%,
            100% {
                background-color: #475569;
                box-shadow: 0 0 5px rgba(239, 68, 68, 0.2);
            }

            50% {
                background-color: #ef4444;
                box-shadow: 0 0 12px rgba(239, 68, 68, 0.5);
            }
        }

        @keyframes idle-soft-gold {

            0%,
            100% {
                background-color: #475569;
                box-shadow: 0 0 5px rgba(251, 191, 36, 0.2);
            }

            50% {
                background-color: #fbbf24;
                box-shadow: 0 0 12px rgba(251, 191, 36, 0.5);
            }
        }

        .idle-soft-turquoise {
            animation: idle-soft-turquoise 4s ease-in-out infinite;
        }

        .idle-soft-red {
            animation: idle-soft-red 4s ease-in-out infinite;
        }

        .idle-soft-gold {
            animation: idle-soft-gold 4s ease-in-out infinite;
        }

        .idle-fadeout {
            animation: none !important;
            transition: background-color 0.2s linear, box-shadow 0.2s linear;
            background-color: #475569 !important;
            box-shadow: none !important;
        }

        /* Timer */
        #time-bar-container {
            height: 10px;
            background-color: #475569;
            border-radius: 9999px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        #time-bar {
            height: 100%;
            width: 100%;
            transition: width 0s linear;
        }

        /* Overlay */
        #start-button-overlay {
            z-index: 10;
            opacity: 1;
            pointer-events: auto;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(30, 41, 59, 0.9);
            border-radius: 12px;
        }

        #start-button {
            box-shadow: 0 0 20px #0b7068, 0 0 10px #119b90;
            border: none;
        }

        #start-button:hover {
            transform: scale(1.05);
        }

        /* Light Mode */
        body.light-mode {
            background-color: #f0f4f8;
            color: #1e293b;
        }

        .light-mode .main-card {
            background-color: #ffffff;
            border-color: #e2e8f0;
        }

        .light-mode .info-panel {
            background-color: #f7f9fc;
        }

        .light-mode .grid-cell {
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
        }

        .light-mode #start-button-overlay {
            background-color: rgba(255, 255, 255, 0.9);
        }

        /* --- Mobile Fixes --- */
        @media (max-width: 640px) {
            body {
                align-items: flex-start;
                justify-content: center;
                min-height: 100dvh;
                padding: 0.5rem;
            }

            .main-card {
                width: 100%;
                max-width: 95vw;
                margin: auto;
            }

            .game-grid {
                width: 100%;
                max-width: 90vw;
                max-height: 90vw;
                margin: 0 auto;
            }

            #start-button {
                font-size: 1rem;
                padding: 0.75rem 1.5rem;
            }

            #game-message {
                font-size: 0.95rem;
            }
        }
    </style>

    <!-- FIREBASE import -->
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js"></script>

</head>

<body class="dark-mode">

    <!-- Theme Switch -->
    <div class="absolute top-4 left-4 z-20">
        <label for="theme-switch" class="flex items-center cursor-pointer theme-switch-label">
            <input id="theme-switch" type="checkbox" class="sr-only">
            <div class="relative">
                <div class="w-10 h-4 rounded-full shadow-inner"></div>
                <div class="dot absolute w-6 h-6 rounded-full shadow -left-1 -top-1"></div>
            </div>
            <span id="theme-label" class="ml-3 text-sm font-medium">Dark Mode</span>
        </label>
    </div>
    
    <!-- Hauptcontainer -->
    <div class="w-full main-card p-6 rounded-xl border">
        <h1 class="text-3xl font-extrabold text-center mb-4 text-title">Gedächtnis-Sequenz-Trainer</h1>
        <p class="text-center text-sm mb-6 font-semibold text-subtitle">
            Merken Sie sich die <b>gesamte Musterabfolge</b> Phase für Phase. Das <b>Zeitlimit</b> gilt für die gesamte
            Runde.
        </p>

        <!-- Status und Timer -->
        <div class="flex justify-between items-center mb-6 p-3 info-panel rounded-lg shadow-inner">
            <div class="text-center">
                <p class="text-xs font-semibold uppercase text-gray-400">Aktuelle Runde</p>
                <p id="current-round" class="text-2xl font-bold text-title">1</p>
            </div>
            <div class="text-center">
                <p class="text-xs font-semibold uppercase text-gray-400">Höchste Runde</p>
                <p id="high-score" class="text-2xl font-bold text-red-400">Laden...</p>
            </div>
        </div>

        <div id="time-bar-container" class="hidden">
            <div id="time-bar"></div>
        </div>

        <!-- Spielgitter -->
        <div id="game-grid" class="game-grid mx-auto grid-bg">
            <div id="grid-container-inner" class="grid-container-inner"></div>

            <div id="start-button-overlay">
                <button id="start-button"
                    class="py-4 px-8 bg-teal-700 text-white font-bold text-xl rounded-full hover:bg-teal-600 transition duration-150 ease-in-out">
                    START
                </button>
            </div>
        </div>

        <!-- Nachrichten -->
        <div class="mt-6 text-center">
            <p id="game-message" class="text-lg font-semibold h-6 mb-4 text-title">Drücken Sie START, um zu beginnen.
            </p>

            <button id="strategy-button"
                class="w-full py-2 px-4 mt-3 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-800 transition duration-150 ease-in-out hidden">
                ✨ Gedächtnistipps anfordern
            </button>

            <div id="strategy-output" class="mt-4 p-4 rounded-lg text-sm text-left border strategy-output hidden">
                <p class="font-bold mb-2 strategy-header">Gedächtnistipps:</p>
                <div id="strategy-content" class="text-subtitle"></div>
                <div id="loading-spinner" class="text-center hidden">
                    <div class="inline-block h-4 w-4 animate-spin rounded-full border-2 border-solid border-current border-r-transparent align-[-0.125em]"
                        role="status"></div>
                    <span class="ml-2 text-gray-400">Lade Tipps...</span>
                </div>
            </div>
        </div>

        <p id="user-info" class="text-xs text-gray-500 mt-4 text-center"></p>
    </div>

    <!-- Kompletter JavaScript-Block (bereinigt & lauffähig) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

  // ----------------------------
  // 🔧 Firebase Setup
  // ----------------------------
  const firebaseConfig = {
    apiKey: "AIzaSyDdZqXYU6oR6yahRt4R5uyObashSScCyf0",
    authDomain: "merkdings.firebaseapp.com",
    projectId: "merkdings",
    storageBucket: "merkdings.firebasestorage.app",
    messagingSenderId: "50434008709",
    appId: "1:50434008709:web:0f1583b896ec853f8b6bec",
    measurementId: "G-ZXRVNCPQ4Y"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  let userId = null;
  let personalHighscore = 0;
  let globalHighscore = 0;

  // ----------------------------
  // 🔥 Initialisierung
  // ----------------------------
  document.addEventListener("DOMContentLoaded", async () => {
    await initializeFirebase();
  });

  async function initializeFirebase() {
    try {
      console.log("🔌 Firebase wird initialisiert...");

      const savedUid = localStorage.getItem("firebaseAnonUid");
      if (savedUid) {
        userId = savedUid;
      } else {
        const result = await signInAnonymously(auth);
        userId = result.user?.uid;
        localStorage.setItem("firebaseAnonUid", userId);
      }

      console.log("✅ Angemeldet als:", userId);

      // Highscores abrufen
      await loadHighscores();

      // Realtime Listener für eigenen Score
      const userRef = doc(db, "artifacts", "memory-app", "users", userId, "memory_game_scores", "high_score");
      onSnapshot(userRef, (docSnap) => {
        if (docSnap.exists()) {
          personalHighscore = docSnap.data().maxRound || 0;
          updateScoreDisplay();
        }
      });

    } catch (err) {
      console.error("❌ Fehler bei Firebase:", err);
      setupLocalHighscore();
    }
  }

  // ----------------------------
  // 🧠 Highscores laden
  // ----------------------------
  async function loadHighscores() {
    const highScoreEl = document.getElementById("high-score");
    if (highScoreEl) highScoreEl.textContent = "0";

    try {
      // Eigener Score
      const userRef = doc(db, "artifacts", "memory-app", "users", userId, "memory_game_scores", "high_score");
      const userSnap = await getDoc(userRef);
      personalHighscore = userSnap.exists() ? userSnap.data().maxRound || 0 : 0;

      // Globaler Score (bester aller Nutzer)
      const globalQuery = query(
        collection(db, "artifacts", "memory-app", "users"),
        orderBy("maxRound", "desc"),
        limit(1)
      );

      const querySnap = await getDocs(globalQuery);
      if (!querySnap.empty) {
        const bestUser = querySnap.docs[0].data();
        globalHighscore = bestUser.maxRound || 0;
      }

      updateScoreDisplay();
      console.log("🏆 Persönlicher Highscore:", personalHighscore);
      console.log("🌍 Globaler Highscore:", globalHighscore);

    } catch (error) {
      console.error("Fehler beim Laden der Highscores:", error);
      setupLocalHighscore();
    }
  }

  // ----------------------------
  // 🔄 Score-Anzeige aktualisieren
  // ----------------------------
  function updateScoreDisplay() {
    const personalEl = document.getElementById("high-score");
    const globalEl = document.getElementById("global-score");

    if (personalEl) personalEl.textContent = personalHighscore;
    if (globalEl) globalEl.textContent = globalHighscore;
  }

  // ----------------------------
  // 💾 Highscore speichern
  // ----------------------------
  window.updateHighScore = async (newRound) => {
    if (newRound <= personalHighscore) return;

    personalHighscore = newRound;
    updateScoreDisplay();

    try {
      const userRef = doc(db, "artifacts", "memory-app", "users", userId, "memory_game_scores", "high_score");
      await setDoc(userRef, { maxRound: newRound, updatedAt: new Date().toISOString() }, { merge: true });
      console.log("✅ Highscore aktualisiert:", newRound);
    } catch (e) {
      console.error("Fehler beim Speichern:", e);
      setupLocalHighscore();
    }
  };

  // ----------------------------
  // 💾 Lokaler Fallback
  // ----------------------------
  function setupLocalHighscore() {
    const saved = parseInt(localStorage.getItem("localHighScore")) || 0;
    personalHighscore = saved;
    document.getElementById("high-score").textContent = saved;
    console.log("📦 Lokaler Highscore aktiv:", saved);
  }

        // --- Spiel-Logik ---
        const GRID_SIZE = 9;
        const GRID_CONTAINER = document.getElementById('grid-container-inner');
        const MESSAGE_ELEMENT = document.getElementById('game-message');
        const ROUND_ELEMENT = document.getElementById('current-round');
        const START_BUTTON_OVERLAY = document.getElementById('start-button-overlay');
        const START_BUTTON = document.getElementById('start-button');
        const TIME_BAR = document.getElementById('time-bar');
        const TIME_BAR_CONTAINER = document.getElementById('time-bar-container');

        let idleInterval = null; // Idle-Interval hier global

        let gameState = {
            round: 1,
            numPhases: 2,
            patternSize: 3,
            sequence: [],
            isFlashing: false,
            isPlayerTurn: false,
            currentPhaseIndex: 0,
            phaseClicks: new Set(),
            flashDuration: 1000,
            waitDuration: 500,
            playerClickTimeLimit: 0,
            flashPhaseDuration: 0,
            timeoutId: null,
        };

        const API_KEY = "";
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Strategie-Anfrage (externes API - optional)
        const requestStrategyTips = async () => {
            const STRATEGY_BUTTON = document.getElementById('strategy-button');
            const STRATEGY_OUTPUT = document.getElementById('strategy-output');
            const STRATEGY_CONTENT = document.getElementById('strategy-content');
            const LOADING_SPINNER = document.getElementById('loading-spinner');

            STRATEGY_BUTTON.disabled = true;
            STRATEGY_OUTPUT.classList.remove('hidden');
            STRATEGY_CONTENT.innerHTML = '';
            LOADING_SPINNER.classList.remove('hidden');

            const systemPrompt = "Sie sind ein freundlicher und motivierender Gedächtnistrainer. Geben Sie klare, umsetzbare Ratschläge, um das Arbeitsgedächtnis und die Sequenzierungsfähigkeit zu verbessern. Antworten Sie in prägnanten Absätzen auf Deutsch. Verwenden Sie Markdown für Formatierungen.";
            const userQuery = "Welche Strategien gibt es, um sich eine Abfolge von 3x3-Quadratmustern in Phasen zu merken, bei denen die Reihenfolge der Klicks innerhalb der Phase nicht wichtig ist? Ich muss 3 Felder in der vorgegebenen Zeit anklicken, bevor ich zur nächsten Phase übergehe.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;

            try {
                const maxRetries = 3;
                let attempt = 0;
                let response;

                while (attempt < maxRetries) {
                    const delay = Math.pow(2, attempt) * 1000;
                    if (attempt > 0) await sleep(delay);

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) break;
                    attempt++;

                    if (attempt === maxRetries) throw new Error(`API-Fehler nach ${maxRetries} Versuchen: ${response.status}`);
                }

                const result = await response.json();
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Konnte keine Tipps generieren.";

                const formattedText = text
                    .replace(/\*\s/g, '• ')
                    .replace(/\n\n/g, '<br><br>')
                    .replace(/\n/g, '<br>');

                STRATEGY_CONTENT.innerHTML = formattedText;

            } catch (error) {
                console.error("Fehler bei der Strategie-Anforderung:", error);
                STRATEGY_CONTENT.innerHTML = "Es ist ein Fehler aufgetreten. Bitte versuchen Sie es später erneut.";
            } finally {
                LOADING_SPINNER.classList.add('hidden');
                STRATEGY_BUTTON.disabled = false;
            }
        };

        // Gitterzellen erstellen
        const createGrid = () => {
            GRID_CONTAINER.innerHTML = '';

            for (let i = 0; i < GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-xl', 'font-bold');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                GRID_CONTAINER.appendChild(cell);
            }
        };

        const calculateClickTimeLimit = () => {
            const baseTimePerPhase = 2500;
            const reductionPerComplexityLevel = 500;
            const minTimePerPhase = 1000;
            const complexityLevel = gameState.numPhases - 2;

            const timePerPhaseAfterReduction = Math.max(
                minTimePerPhase,
                baseTimePerPhase - complexityLevel * reductionPerComplexityLevel
            );

            return timePerPhaseAfterReduction * gameState.numPhases;
        }

        const startGame = async () => {
            stopIdleAnimation();

            const cells = Array.from(GRID_CONTAINER.children);
            cells.forEach(c => {
                c.classList.remove('idle-soft-turquoise', 'idle-soft-red', 'idle-soft-gold');
                c.classList.add('idle-fadeout');
                setTimeout(() => {
                    c.classList.remove('idle-fadeout');
                }, 250);
                c.style.animation = 'none';
                void c.offsetWidth;
                c.style.animation = '';
            });

            if (gameState.isFlashing || gameState.isPlayerTurn) return;

            START_BUTTON_OVERLAY.style.pointerEvents = 'none';
            START_BUTTON_OVERLAY.style.opacity = '0';
            START_BUTTON_OVERLAY.style.transform = 'scale(0.9)';

            await sleep(100);
            START_BUTTON_OVERLAY.classList.add('hidden');

            if (gameState.round === 1) {
                gameState.numPhases = 2;
                clearGridClasses();
            }

            stopCurrentTimer();
            gameState.isFlashing = true;
            gameState.isPlayerTurn = false;
            gameState.currentPhaseIndex = 0;
            gameState.phaseClicks.clear();

            MESSAGE_ELEMENT.textContent = 'Merken Sie sich die Sequenz (Phase 1)...';
            TIME_BAR_CONTAINER.classList.remove('hidden');

            document.getElementById('strategy-button').classList.add('hidden');
            document.getElementById('strategy-output').classList.add('hidden');

            gameState.sequence = generateSequence(gameState.numPhases, gameState.patternSize);

            gameState.flashPhaseDuration = gameState.numPhases * gameState.flashDuration + (gameState.numPhases - 1) * gameState.waitDuration;
            gameState.playerClickTimeLimit = calculateClickTimeLimit();

            startPhaseTimer(gameState.flashPhaseDuration, 'flash');

            await flashSequence();
            stopIdleAnimation();
        };

        const generateSequence = (numPhases, patternSize) => {
            const seq = [];
            const allIndices = Array.from({ length: GRID_SIZE }, (_, i) => i);

            for (let i = 0; i < numPhases; i++) {
                const pattern = [];
                let availableIndices = [...allIndices];

                for (let k = 0; k < Math.min(patternSize, GRID_SIZE); k++) {
                    const randomIndex = Math.floor(Math.random() * availableIndices.length);
                    const selectedIndex = availableIndices[randomIndex];

                    pattern.push(selectedIndex);
                    availableIndices.splice(randomIndex, 1);
                }
                seq.push(pattern);
            }
            return seq;
        };

        const flashSequence = async () => {
            const cells = Array.from(GRID_CONTAINER.children);

            for (let i = 0; i < gameState.sequence.length; i++) {
                if (!gameState.isFlashing) return;

                const pattern = gameState.sequence[i];

                MESSAGE_ELEMENT.textContent = `Merken Sie sich die Sequenz (Phase ${i + 1})...`;

                const activeCells = pattern.map(index => cells[index]);

                activeCells.forEach(cell => cell.classList.add('flash-active'));
                await sleep(gameState.flashDuration);

                activeCells.forEach(cell => cell.classList.remove('flash-active'));

                if (i < gameState.sequence.length - 1) {
                    await sleep(gameState.waitDuration);
                }
            }

            if (gameState.isFlashing) {
                stopCurrentTimer();
                startClickPhase();
            }
        };

        const startPhaseTimer = (duration, phaseType) => {
            stopCurrentTimer();

            let barColor;

            if (phaseType === 'flash') {
                barColor = '#fde047';
            } else if (phaseType === 'click') {
                barColor = '#f87171';
            }

            TIME_BAR.style.backgroundColor = barColor;
            TIME_BAR.style.transition = 'none';
            TIME_BAR.style.width = '100%';
            void TIME_BAR.offsetWidth;
            TIME_BAR.style.transition = `width ${duration}ms linear`;
            TIME_BAR.style.width = '0%';

            gameState.timeoutId = setTimeout(() => {
                handlePhaseTimeout(phaseType);
            }, duration);
        };

        const stopCurrentTimer = () => {
            if (gameState.timeoutId) {
                clearTimeout(gameState.timeoutId);
                gameState.timeoutId = null;
            }
            TIME_BAR.style.transition = 'none';
            TIME_BAR.style.width = '100%';
        };

        const startClickPhase = () => {
            gameState.isFlashing = false;
            gameState.isPlayerTurn = true;
            MESSAGE_ELEMENT.textContent = `Klicken Sie die Felder der Phase ${gameState.currentPhaseIndex + 1}! (Zeit läuft)`;

            startPhaseTimer(gameState.playerClickTimeLimit, 'click');
        };

        const handlePhaseTimeout = (phaseType) => {
            if (phaseType === 'flash') {
                if (gameState.isFlashing) {
                    console.log("Merkphase Timeout, aber Flashing läuft noch. Erzwinge Klickphase.");
                    gameState.isFlashing = false;
                    startClickPhase();
                }

            } else if (phaseType === 'click') {
                if (!gameState.isPlayerTurn) return;

                stopCurrentTimer();
                MESSAGE_ELEMENT.textContent = `ZEIT ABGELAUFEN! Game Over. Ihre erreichte Runde: ${gameState.round}.`;
                handleFailure(true);
            }
        };

        async function handleCellClick(event) {
            if (!gameState.isPlayerTurn) {
                console.log("Klick ignoriert: Nicht die Spielerrunde.");
                return;
            }

            const clickedCell = event.currentTarget;
            const clickedIndex = parseInt(clickedCell.dataset.index);

            const expectedPattern = gameState.sequence[gameState.currentPhaseIndex];

            if (expectedPattern.includes(clickedIndex)) {
                if (gameState.phaseClicks.has(clickedIndex)) {
                    return;
                }

                gameState.phaseClicks.add(clickedIndex);
                clickedCell.classList.add('phase-complete');

                clickedCell.classList.add('correct-click');
                setTimeout(() => clickedCell.classList.remove('correct-click'), 150);

                if (gameState.phaseClicks.size === gameState.patternSize) {
                    gameState.isPlayerTurn = false;

                    const cells = Array.from(GRID_CONTAINER.children);
                    const completedPattern = gameState.sequence[gameState.currentPhaseIndex];

                    completedPattern.forEach(index => {
                        cells[index].classList.remove('phase-complete');
                        cells[index].classList.add('correct-click');
                        setTimeout(() => cells[index].classList.remove('correct-click'), 300);
                    });

                    gameState.currentPhaseIndex++;

                    if (gameState.currentPhaseIndex === gameState.sequence.length) {
                        handleSuccess();
                    } else {
                        MESSAGE_ELEMENT.textContent = `Phase ${gameState.currentPhaseIndex} abgeschlossen! Klicken Sie die Felder der Phase ${gameState.currentPhaseIndex + 1}! (Zeit läuft)`;

                        gameState.phaseClicks.clear();
                        gameState.isPlayerTurn = true;
                    }
                }

            } else {
                stopCurrentTimer();
                clickedCell.classList.add('wrong-click');
                handleFailure(false);
            }
        }

        const handleSuccess = async () => {
            gameState.isPlayerTurn = false;
            stopCurrentTimer();

            MESSAGE_ELEMENT.textContent = 'Runde bestanden! Nächste Runde wird vorbereitet...';

            await sleep(1500);

            const completedRound = gameState.round;
            window.updateHighScore(completedRound);

            gameState.round++;

            if ((gameState.round - 1) % 3 === 0) {
                gameState.numPhases++;
            }

            ROUND_ELEMENT.textContent = gameState.round;

            clearGridClasses();
            await sleep(500);

            startGame();
        };

        const handleFailure = async (isTimeout) => {
            gameState.isPlayerTurn = false;
            stopCurrentTimer();

            const cells = Array.from(GRID_CONTAINER.children);
            const expectedPattern = gameState.sequence[gameState.currentPhaseIndex] || [];
            const allMissingIndices = expectedPattern.filter(index => !gameState.phaseClicks.has(index));

            if (allMissingIndices.length > 0) {
                MESSAGE_ELEMENT.textContent = isTimeout
                    ? `ZEIT ABGELAUFEN! Game Over.`
                    : `FALSCH! Game Over.`;
            } else {
                MESSAGE_ELEMENT.textContent = `Game Over. Ihre erreichte Runde: ${gameState.round}.`;
            }

            cells.forEach(cell => cell.classList.add('wrong-click'));

            gameState.phaseClicks.forEach(index => {
                const correctCell = cells[index];
                if (correctCell) {
                    correctCell.classList.remove('wrong-click');
                    correctCell.classList.add('correct-before-failure');
                }
            });

            allMissingIndices.forEach(missingIndex => {
                const missedCell = cells[missingIndex];
                if (missedCell) {
                    missedCell.classList.remove('wrong-click');
                    missedCell.classList.add('should-have-been-clicked');
                }
            });

            await sleep(3000);

            //gameState.round = 1;
            //ROUND_ELEMENT.textContent = gameState.round;

            

            START_BUTTON.textContent = 'NEU STARTEN';
            START_BUTTON_OVERLAY.classList.remove('hidden');
            START_BUTTON_OVERLAY.style.opacity = '1';
            START_BUTTON_OVERLAY.style.transform = 'scale(1)';
            START_BUTTON_OVERLAY.style.pointerEvents = 'auto';

            document.getElementById('strategy-button').classList.remove('hidden');

            if (isTimeout) {
                startIdleAnimation('idle-soft-gold');
            } else {
                startIdleAnimation('idle-soft-red');
            }
        };

        const clearGridClasses = () => {
            const cells = Array.from(GRID_CONTAINER.children);
            cells.forEach(cell => {
                cell.classList.remove(
                    'flash-active',
                    'correct-click',
                    'wrong-click',
                    'phase-complete',
                    'should-have-been-clicked',
                    'correct-before-failure'
                );
            });
        }

        // Theme-Switch
        const setupThemeSwitch = () => {
            const body = document.body;
            const switchInput = document.getElementById('theme-switch');
            const switchLabel = document.getElementById('theme-label');

            const setDarkMode = (isDark) => {
                if (isDark) {
                    body.classList.remove('light-mode');
                    body.classList.add('dark-mode');
                    switchInput.checked = false;
                    //switchLabel.textContent = 'Dark Mode';
                } else {
                    body.classList.add('light-mode');
                    body.classList.remove('dark-mode');
                    switchInput.checked = true;
                    switchLabel.textContent = 'Light Mode';
                }
            };

            setDarkMode(true);

            switchInput.addEventListener('change', () => {
                setDarkMode(!switchInput.checked);
            });

        };

        // Idle Animation
        function startIdleAnimation(colorClass = 'idle-soft-turquoise') {
            stopIdleAnimation();

            idleInterval = setInterval(() => {
                const cells = Array.from(GRID_CONTAINER.children);
                if (cells.length === 0) return;
                const randomCell = cells[Math.floor(Math.random() * cells.length)];

                randomCell.classList.add(colorClass);

                setTimeout(() => {
                    randomCell.classList.remove(colorClass);
                }, 4000);
            }, 1500);
        }

        function stopIdleAnimation() {
            if (idleInterval) {
                clearInterval(idleInterval);
                idleInterval = null;
            }
            const cells = Array.from(GRID_CONTAINER.children);
            cells.forEach(c => {
                c.classList.remove('idle-soft-turquoise', 'idle-soft-red', 'idle-soft-gold', 'idle-fadeout');
            });
        }

        function showRestartOverlay() {
            START_BUTTON.textContent = 'NEU STARTEN';
            START_BUTTON_OVERLAY.classList.remove('hidden');
            START_BUTTON_OVERLAY.style.opacity = '1';
            START_BUTTON_OVERLAY.style.transform = 'scale(1)';
            START_BUTTON_OVERLAY.style.pointerEvents = 'auto';
            startIdleAnimation();
        }

        // Initialisierung auf load (einmalig, sauber)
        window.addEventListener('load', () => {
            createGrid();
            initializeFirebase();
            setupThemeSwitch();

            // Start: stoppe Idle und starte Spiel
            START_BUTTON.addEventListener('click', () => {
                stopIdleAnimation();
            
                if (START_BUTTON.textContent === 'NEU STARTEN') {
                    // Nur bei echtem Neustart alles zurücksetzen
                    isRestart = true;
                    gameState.round = 1;
                    ROUND_ELEMENT.textContent = gameState.round;
                } else {
                    isRestart = false;
                }
            
                // Felder säubern und verstecken
                clearGridClasses();
                START_BUTTON_OVERLAY.classList.add('hidden');
            
                startGame();
            });

            document.getElementById('strategy-button').addEventListener('click', requestStrategyTips);

            // Idle gleich beim Laden starten
            startIdleAnimation();
        });

    </script>

</body>


</html>






























